//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Checks if the current session is authenticated
     * @return Session is valid and authenticated, or authentication is disabled
     */
    isLoggedIn(): Promise<void> {
        let url_ = this.baseUrl + "/Api/Authentication/IsLoggedIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsLoggedIn(_response);
        });
    }

    protected processIsLoggedIn(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 402) {
            return response.text().then((_responseText) => {
            let result402: any = null;
            let resultData402 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result402 = ProblemDetails.fromJS(resultData402);
            return throwException("System requires initial setup - no users exist in the database", status, _responseText, _headers, result402);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Session is not authenticated", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Creates the initial account for the system
     * @param request (optional) Registration details for the new account
     * @return Account created successfully and user is logged in
     */
    create(request: AuthControllerLoginRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Authentication/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid request - username/password missing or validation failed", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Cannot create account - a user already exists in system", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Configures the provider settings for the application
     * @param request (optional) Provider configuration details including provider type and API token
     * @return Provider configured successfully
     */
    setupProvider(request: AuthControllerSetupProviderRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Authentication/SetupProvider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetupProvider(_response);
        });
    }

    protected processSetupProvider(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid request - missing required fields", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Provider already configured", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Authenticates a user and creates a new session
     * @param request (optional) Login credentials
     * @return Authentication successful
     */
    login(request: AuthControllerLoginRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Api/Authentication/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid credentials or missing required fields", status, _responseText, _headers, result400);
            });
        } else if (status === 402) {
            return response.text().then((_responseText) => {
            let result402: any = null;
            let resultData402 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result402 = ProblemDetails.fromJS(resultData402);
            return throwException("System requires initial setup - no users exist", status, _responseText, _headers, result402);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Ends the current authenticated session
     * @return Session terminated successfully
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/Api/Authentication/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates the authenticated user's password
     * @param request (optional) Password update request containing the new password
     * @return Password updated successfully
     */
    update(request: AuthControllerUpdateRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Api/Authentication/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid request or password validation failed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class SettingsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves all application settings
     * @return Returns the list of settings
     */
    get(): Promise<SettingProperty[]> {
        let url_ = this.baseUrl + "/Api/Settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SettingProperty[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingProperty.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingProperty[]>(null as any);
    }

    /**
     * Updates multiple application settings
     * @param settings1 (optional) List of setting properties to update
     * @return Settings were successfully updated
     */
    update(settings1: SettingKeyValuePair[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings1);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid settings data provided", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retrieves the profile information from the currently configured debrid service
     * @return The profile information
     */
    profile(): Promise<Profile> {
        let url_ = this.baseUrl + "/Api/Settings/Profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfile(_response);
        });
    }

    protected processProfile(response: Response): Promise<Profile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Profile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Profile>(null as any);
    }

    /**
     * Gets the version of rdt-client the server is running
     * @return The Version Number
     */
    version(): Promise<Version> {
        let url_ = this.baseUrl + "/Api/Settings/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVersion(_response);
        });
    }

    protected processVersion(response: Response): Promise<Version> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Version.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Version>(null as any);
    }

    /**
     * Tests if a specified path is writable by attempting to create and delete a test file
     * @param request (optional) The path testing request containing the directory to test
     * @return The path is valid and writable
     */
    testPath(request: SettingsControllerTestPathRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Settings/TestPath";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestPath(_response);
        });
    }

    protected processTestPath(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Invalid or empty path provided", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Path does not exist or is not accessible", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Tests download speed by downloading a sample file and measuring throughput
     * @return Returns the measured download speed
     */
    testDownloadSpeed(): Promise<number> {
        let url_ = this.baseUrl + "/Api/Settings/TestDownloadSpeed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestDownloadSpeed(_response);
        });
    }

    protected processTestDownloadSpeed(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Tests write speed to the configured download directory
     * @return Returns the measured write speed
     */
    testWriteSpeed(): Promise<number> {
        let url_ = this.baseUrl + "/Api/Settings/TestWriteSpeed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestWriteSpeed(_response);
        });
    }

    protected processTestWriteSpeed(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Tests the connection to an Aria2c instance
     * @param request (optional) The connection details for the Aria2c instance
     * @return Returns the Aria2c version information
     */
    testAria2cConnection(request: SettingsControllerTestAria2cConnectionRequest | undefined): Promise<string> {
        let url_ = this.baseUrl + "/Api/Settings/TestAria2cConnection";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestAria2cConnection(_response);
        });
    }

    protected processTestAria2cConnection(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid or missing connection details", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Connection to Aria2c failed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class TorrentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves all torrents and their associated downloads
     * @return Returns the list of torrents
     */
    getAll(): Promise<Torrent[]> {
        let url_ = this.baseUrl + "/Api/Torrents";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Torrent[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Torrent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Torrent[]>(null as any);
    }

    /**
     * Retrieves a specific torrent by its ID
     * @param torrentId The unique identifier of the torrent
     * @return Returns the requested torrent
     */
    getById(torrentId: string): Promise<Torrent> {
        let url_ = this.baseUrl + "/Api/Torrents/Get/{torrentId}";
        if (torrentId === undefined || torrentId === null)
            throw new Error("The parameter 'torrentId' must be defined.");
        url_ = url_.replace("{torrentId}", encodeURIComponent("" + torrentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<Torrent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Torrent.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Torrent not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Torrent>(null as any);
    }

    /**
     * Forces an immediate processing cycle for debugging purposes
     * @return Processing cycle completed successfully
     */
    tick(): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/Tick";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTick(_response);
        });
    }

    protected processTick(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds a new torrent file with configuration
     * @param formData (optional) Configuration for the torrent download
     * @param file (optional) 
     * @return Torrent added successfully
     */
    uploadFile(formData: TorrentControllerUploadFileRequest | null | undefined, file: FileParameter | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/UploadFile?";
        if (formData !== undefined && formData !== null)
            url_ += "formData=" + encodeURIComponent("" + formData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Invalid file or configuration provided", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds a new torrent using a magnet link
     * @param request (optional) The magnet link and torrent configuration
     * @return Magnet link processed successfully
     */
    uploadMagnet(request: TorrentControllerUploadMagnetRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/UploadMagnet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadMagnet(_response);
        });
    }

    protected processUploadMagnet(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Invalid magnet link or configuration", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Checks available files in a torrent file
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Returns the list of available files
     */
    checkFiles(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any[] | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Promise<TorrentClientAvailableFile[]> {
        let url_ = this.baseUrl + "/Api/Torrents/CheckFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckFiles(_response);
        });
    }

    protected processCheckFiles(response: Response): Promise<TorrentClientAvailableFile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TorrentClientAvailableFile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Invalid torrent file provided", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TorrentClientAvailableFile[]>(null as any);
    }

    /**
     * Checks available files from a magnet link
     * @param request (optional) The magnet link to analyze
     * @return Returns the list of available files
     */
    checkFilesMagnet(request: TorrentControllerCheckFilesRequest | undefined): Promise<TorrentClientAvailableFile[]> {
        let url_ = this.baseUrl + "/Api/Torrents/CheckFilesMagnet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckFilesMagnet(_response);
        });
    }

    protected processCheckFilesMagnet(response: Response): Promise<TorrentClientAvailableFile[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TorrentClientAvailableFile.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Invalid magnet link provided", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TorrentClientAvailableFile[]>(null as any);
    }

    /**
     * Deletes a torrent and optionally its associated data
     * @param torrentId The unique identifier of the torrent to delete
     * @param request (optional) Delete options specifying what should be removed
     * @return Torrent deleted successfully
     */
    delete(torrentId: string, request: TorrentControllerDeleteRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/Delete/{torrentId}";
        if (torrentId === undefined || torrentId === null)
            throw new Error("The parameter 'torrentId' must be defined.");
        url_ = url_.replace("{torrentId}", encodeURIComponent("" + torrentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid request parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retries a failed torrent download
     * @param torrentId The unique identifier of the torrent to retry
     * @return Retry initiated successfully
     */
    retry(torrentId: string): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/Retry/{torrentId}";
        if (torrentId === undefined || torrentId === null)
            throw new Error("The parameter 'torrentId' must be defined.");
        url_ = url_.replace("{torrentId}", encodeURIComponent("" + torrentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetry(_response);
        });
    }

    protected processRetry(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retries a failed download within a torrent
     * @param downloadId The unique identifier of the download to retry
     * @return Retry initiated successfully
     */
    retryDownload(downloadId: string): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/RetryDownload/{downloadId}";
        if (downloadId === undefined || downloadId === null)
            throw new Error("The parameter 'downloadId' must be defined.");
        url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetryDownload(_response);
        });
    }

    protected processRetryDownload(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates torrent configuration
     * @param torrent (optional) The updated torrent configuration
     * @return Torrent updated successfully
     */
    update(torrent: Torrent | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Api/Torrents/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(torrent);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid torrent configuration", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Tests regex patterns against torrent files
     * @param request (optional) The regex patterns and magnet link to test
     * @return Returns the regex test results
     */
    verifyRegex(request: TorrentControllerVerifyRegexRequest | undefined): Promise<RegexVerificationResult> {
        let url_ = this.baseUrl + "/Api/Torrents/VerifyRegex";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerifyRegex(_response);
        });
    }

    protected processVerifyRegex(response: Response): Promise<RegexVerificationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegexVerificationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid request parameters", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegexVerificationResult>(null as any);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Request model for login and user creation operations */
export class AuthControllerLoginRequest implements IAuthControllerLoginRequest {
    /** Username for authentication */
    userName!: string;
    /** Password for authentication */
    password!: string;

    constructor(data?: IAuthControllerLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthControllerLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthControllerLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

/** Request model for login and user creation operations */
export interface IAuthControllerLoginRequest {
    /** Username for authentication */
    userName: string;
    /** Password for authentication */
    password: string;
}

/** Request model for configuring the provider settings */
export class AuthControllerSetupProviderRequest implements IAuthControllerSetupProviderRequest {
    /** Provider type identifier */
    provider!: number;
    /** API token or key for the provider */
    token!: string;

    constructor(data?: IAuthControllerSetupProviderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthControllerSetupProviderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthControllerSetupProviderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["token"] = this.token;
        return data;
    }
}

/** Request model for configuring the provider settings */
export interface IAuthControllerSetupProviderRequest {
    /** Provider type identifier */
    provider: number;
    /** API token or key for the provider */
    token: string;
}

/** Request model for updating user password */
export class AuthControllerUpdateRequest implements IAuthControllerUpdateRequest {
    /** Username for the account */
    userName!: string;
    /** New password for the user account */
    password!: string;

    constructor(data?: IAuthControllerUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthControllerUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthControllerUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

/** Request model for updating user password */
export interface IAuthControllerUpdateRequest {
    /** Username for the account */
    userName: string;
    /** New password for the user account */
    password: string;
}

export class SettingKeyValuePair implements ISettingKeyValuePair {
    key?: string;
    value?: any | undefined;

    constructor(data?: ISettingKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new SettingKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface ISettingKeyValuePair {
    key?: string;
    value?: any | undefined;
}

export class SettingProperty extends SettingKeyValuePair implements ISettingProperty {
    displayName?: string | undefined;
    description?: string | undefined;
    type?: string;
    enumValues?: { [key: string]: string; } | undefined;

    constructor(data?: ISettingProperty) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.type = _data["type"];
            if (_data["enumValues"]) {
                this.enumValues = {} as any;
                for (let key in _data["enumValues"]) {
                    if (_data["enumValues"].hasOwnProperty(key))
                        (<any>this.enumValues)![key] = _data["enumValues"][key];
                }
            }
        }
    }

    static override fromJS(data: any): SettingProperty {
        data = typeof data === 'object' ? data : {};
        let result = new SettingProperty();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["type"] = this.type;
        if (this.enumValues) {
            data["enumValues"] = {};
            for (let key in this.enumValues) {
                if (this.enumValues.hasOwnProperty(key))
                    (<any>data["enumValues"])[key] = (<any>this.enumValues)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISettingProperty extends ISettingKeyValuePair {
    displayName?: string | undefined;
    description?: string | undefined;
    type?: string;
    enumValues?: { [key: string]: string; } | undefined;
}

export class Profile implements IProfile {
    provider?: string | undefined;
    userName?: string | undefined;
    expiration?: Date | undefined;
    currentVersion?: string | undefined;
    latestVersion?: string | undefined;
    isInsecure?: boolean | undefined;
    disableUpdateNotification?: boolean | undefined;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.userName = _data["userName"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.currentVersion = _data["currentVersion"];
            this.latestVersion = _data["latestVersion"];
            this.isInsecure = _data["isInsecure"];
            this.disableUpdateNotification = _data["disableUpdateNotification"];
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["userName"] = this.userName;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["currentVersion"] = this.currentVersion;
        data["latestVersion"] = this.latestVersion;
        data["isInsecure"] = this.isInsecure;
        data["disableUpdateNotification"] = this.disableUpdateNotification;
        return data;
    }
}

export interface IProfile {
    provider?: string | undefined;
    userName?: string | undefined;
    expiration?: Date | undefined;
    currentVersion?: string | undefined;
    latestVersion?: string | undefined;
    isInsecure?: boolean | undefined;
    disableUpdateNotification?: boolean | undefined;
}

export class Version implements IVersion {
    major?: number;
    minor?: number;
    build?: number;
    revision?: number;
    majorRevision?: number;
    minorRevision?: number;

    constructor(data?: IVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.major = _data["major"];
            this.minor = _data["minor"];
            this.build = _data["build"];
            this.revision = _data["revision"];
            this.majorRevision = _data["majorRevision"];
            this.minorRevision = _data["minorRevision"];
        }
    }

    static fromJS(data: any): Version {
        data = typeof data === 'object' ? data : {};
        let result = new Version();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["build"] = this.build;
        data["revision"] = this.revision;
        data["majorRevision"] = this.majorRevision;
        data["minorRevision"] = this.minorRevision;
        return data;
    }
}

export interface IVersion {
    major?: number;
    minor?: number;
    build?: number;
    revision?: number;
    majorRevision?: number;
    minorRevision?: number;
}

/** Request model for testing path accessibility */
export class SettingsControllerTestPathRequest implements ISettingsControllerTestPathRequest {
    /** The directory path to test for write access */
    path!: string;

    constructor(data?: ISettingsControllerTestPathRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): SettingsControllerTestPathRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsControllerTestPathRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        return data;
    }
}

/** Request model for testing path accessibility */
export interface ISettingsControllerTestPathRequest {
    /** The directory path to test for write access */
    path: string;
}

/** Request model for testing Aria2c connection */
export class SettingsControllerTestAria2cConnectionRequest implements ISettingsControllerTestAria2cConnectionRequest {
    /** The URL of the Aria2c RPC endpoint */
    url!: string;
    /** The secret token for authenticating with the Aria2c server */
    secret!: string;

    constructor(data?: ISettingsControllerTestAria2cConnectionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.secret = _data["secret"];
        }
    }

    static fromJS(data: any): SettingsControllerTestAria2cConnectionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsControllerTestAria2cConnectionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["secret"] = this.secret;
        return data;
    }
}

/** Request model for testing Aria2c connection */
export interface ISettingsControllerTestAria2cConnectionRequest {
    /** The URL of the Aria2c RPC endpoint */
    url: string;
    /** The secret token for authenticating with the Aria2c server */
    secret: string;
}

export class Torrent implements ITorrent {
    torrentId?: string;
    hash?: string;
    category?: string | undefined;
    downloadAction?: TorrentDownloadAction;
    finishedAction?: TorrentFinishedAction;
    hostDownloadAction?: TorrentHostDownloadAction;
    downloadMinSize?: number;
    includeRegex?: string | undefined;
    excludeRegex?: string | undefined;
    downloadManualFiles?: string | undefined;
    downloadClient?: DownloadClient;
    added?: Date;
    filesSelected?: Date | undefined;
    completed?: Date | undefined;
    retry?: Date | undefined;
    fileOrMagnet?: string | undefined;
    isFile?: boolean;
    priority?: number | undefined;
    retryCount?: number;
    downloadRetryAttempts?: number;
    torrentRetryAttempts?: number;
    deleteOnError?: number;
    lifetime?: number;
    error?: string | undefined;
    downloads?: Download[];
    clientKind?: Provider | undefined;
    rdId?: string | undefined;
    rdName?: string | undefined;
    rdSize?: number | undefined;
    rdHost?: string | undefined;
    rdSplit?: number | undefined;
    rdProgress?: number | undefined;
    rdStatus?: TorrentStatus | undefined;
    rdStatusRaw?: string | undefined;
    rdAdded?: Date | undefined;
    rdEnded?: Date | undefined;
    rdSpeed?: number | undefined;
    rdSeeders?: number | undefined;
    rdFiles?: string | undefined;
    files?: TorrentClientFile[];
    manualFiles?: string[];

    constructor(data?: ITorrent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.torrentId = _data["torrentId"];
            this.hash = _data["hash"];
            this.category = _data["category"];
            this.downloadAction = _data["downloadAction"];
            this.finishedAction = _data["finishedAction"];
            this.hostDownloadAction = _data["hostDownloadAction"];
            this.downloadMinSize = _data["downloadMinSize"];
            this.includeRegex = _data["includeRegex"];
            this.excludeRegex = _data["excludeRegex"];
            this.downloadManualFiles = _data["downloadManualFiles"];
            this.downloadClient = _data["downloadClient"];
            this.added = _data["added"] ? new Date(_data["added"].toString()) : <any>undefined;
            this.filesSelected = _data["filesSelected"] ? new Date(_data["filesSelected"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.retry = _data["retry"] ? new Date(_data["retry"].toString()) : <any>undefined;
            this.fileOrMagnet = _data["fileOrMagnet"];
            this.isFile = _data["isFile"];
            this.priority = _data["priority"];
            this.retryCount = _data["retryCount"];
            this.downloadRetryAttempts = _data["downloadRetryAttempts"];
            this.torrentRetryAttempts = _data["torrentRetryAttempts"];
            this.deleteOnError = _data["deleteOnError"];
            this.lifetime = _data["lifetime"];
            this.error = _data["error"];
            if (Array.isArray(_data["downloads"])) {
                this.downloads = [] as any;
                for (let item of _data["downloads"])
                    this.downloads!.push(Download.fromJS(item));
            }
            this.clientKind = _data["clientKind"];
            this.rdId = _data["rdId"];
            this.rdName = _data["rdName"];
            this.rdSize = _data["rdSize"];
            this.rdHost = _data["rdHost"];
            this.rdSplit = _data["rdSplit"];
            this.rdProgress = _data["rdProgress"];
            this.rdStatus = _data["rdStatus"];
            this.rdStatusRaw = _data["rdStatusRaw"];
            this.rdAdded = _data["rdAdded"] ? new Date(_data["rdAdded"].toString()) : <any>undefined;
            this.rdEnded = _data["rdEnded"] ? new Date(_data["rdEnded"].toString()) : <any>undefined;
            this.rdSpeed = _data["rdSpeed"];
            this.rdSeeders = _data["rdSeeders"];
            this.rdFiles = _data["rdFiles"];
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(TorrentClientFile.fromJS(item));
            }
            if (Array.isArray(_data["manualFiles"])) {
                this.manualFiles = [] as any;
                for (let item of _data["manualFiles"])
                    this.manualFiles!.push(item);
            }
        }
    }

    static fromJS(data: any): Torrent {
        data = typeof data === 'object' ? data : {};
        let result = new Torrent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["torrentId"] = this.torrentId;
        data["hash"] = this.hash;
        data["category"] = this.category;
        data["downloadAction"] = this.downloadAction;
        data["finishedAction"] = this.finishedAction;
        data["hostDownloadAction"] = this.hostDownloadAction;
        data["downloadMinSize"] = this.downloadMinSize;
        data["includeRegex"] = this.includeRegex;
        data["excludeRegex"] = this.excludeRegex;
        data["downloadManualFiles"] = this.downloadManualFiles;
        data["downloadClient"] = this.downloadClient;
        data["added"] = this.added ? this.added.toISOString() : <any>undefined;
        data["filesSelected"] = this.filesSelected ? this.filesSelected.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["retry"] = this.retry ? this.retry.toISOString() : <any>undefined;
        data["fileOrMagnet"] = this.fileOrMagnet;
        data["isFile"] = this.isFile;
        data["priority"] = this.priority;
        data["retryCount"] = this.retryCount;
        data["downloadRetryAttempts"] = this.downloadRetryAttempts;
        data["torrentRetryAttempts"] = this.torrentRetryAttempts;
        data["deleteOnError"] = this.deleteOnError;
        data["lifetime"] = this.lifetime;
        data["error"] = this.error;
        if (Array.isArray(this.downloads)) {
            data["downloads"] = [];
            for (let item of this.downloads)
                data["downloads"].push(item.toJSON());
        }
        data["clientKind"] = this.clientKind;
        data["rdId"] = this.rdId;
        data["rdName"] = this.rdName;
        data["rdSize"] = this.rdSize;
        data["rdHost"] = this.rdHost;
        data["rdSplit"] = this.rdSplit;
        data["rdProgress"] = this.rdProgress;
        data["rdStatus"] = this.rdStatus;
        data["rdStatusRaw"] = this.rdStatusRaw;
        data["rdAdded"] = this.rdAdded ? this.rdAdded.toISOString() : <any>undefined;
        data["rdEnded"] = this.rdEnded ? this.rdEnded.toISOString() : <any>undefined;
        data["rdSpeed"] = this.rdSpeed;
        data["rdSeeders"] = this.rdSeeders;
        data["rdFiles"] = this.rdFiles;
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (Array.isArray(this.manualFiles)) {
            data["manualFiles"] = [];
            for (let item of this.manualFiles)
                data["manualFiles"].push(item);
        }
        return data;
    }
}

export interface ITorrent {
    torrentId?: string;
    hash?: string;
    category?: string | undefined;
    downloadAction?: TorrentDownloadAction;
    finishedAction?: TorrentFinishedAction;
    hostDownloadAction?: TorrentHostDownloadAction;
    downloadMinSize?: number;
    includeRegex?: string | undefined;
    excludeRegex?: string | undefined;
    downloadManualFiles?: string | undefined;
    downloadClient?: DownloadClient;
    added?: Date;
    filesSelected?: Date | undefined;
    completed?: Date | undefined;
    retry?: Date | undefined;
    fileOrMagnet?: string | undefined;
    isFile?: boolean;
    priority?: number | undefined;
    retryCount?: number;
    downloadRetryAttempts?: number;
    torrentRetryAttempts?: number;
    deleteOnError?: number;
    lifetime?: number;
    error?: string | undefined;
    downloads?: Download[];
    clientKind?: Provider | undefined;
    rdId?: string | undefined;
    rdName?: string | undefined;
    rdSize?: number | undefined;
    rdHost?: string | undefined;
    rdSplit?: number | undefined;
    rdProgress?: number | undefined;
    rdStatus?: TorrentStatus | undefined;
    rdStatusRaw?: string | undefined;
    rdAdded?: Date | undefined;
    rdEnded?: Date | undefined;
    rdSpeed?: number | undefined;
    rdSeeders?: number | undefined;
    rdFiles?: string | undefined;
    files?: TorrentClientFile[];
    manualFiles?: string[];
}

export enum TorrentDownloadAction {
    DownloadAll = 0,
    DownloadAvailableFiles = 1,
    DownloadManual = 2,
}

export enum TorrentFinishedAction {
    None = 0,
    RemoveAllTorrents = 1,
    RemoveRealDebrid = 2,
    RemoveClient = 3,
}

export enum TorrentHostDownloadAction {
    DownloadAll = 0,
    DownloadNone = 1,
}

export enum DownloadClient {
    Internal = 0,
    Bezzad = 1,
    Aria2c = 2,
    Symlink = 3,
    DownloadStation = 4,
}

export class Download implements IDownload {
    downloadId?: string;
    torrentId?: string;
    torrent?: Torrent | undefined;
    path?: string;
    link?: string | undefined;
    added?: Date;
    downloadQueued?: Date | undefined;
    downloadStarted?: Date | undefined;
    downloadFinished?: Date | undefined;
    unpackingQueued?: Date | undefined;
    unpackingStarted?: Date | undefined;
    unpackingFinished?: Date | undefined;
    completed?: Date | undefined;
    retryCount?: number;
    error?: string | undefined;
    remoteId?: string | undefined;
    fileName?: string | undefined;
    bytesTotal?: number;
    bytesDone?: number;
    speed?: number;

    constructor(data?: IDownload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadId = _data["downloadId"];
            this.torrentId = _data["torrentId"];
            this.torrent = _data["torrent"] ? Torrent.fromJS(_data["torrent"]) : <any>undefined;
            this.path = _data["path"];
            this.link = _data["link"];
            this.added = _data["added"] ? new Date(_data["added"].toString()) : <any>undefined;
            this.downloadQueued = _data["downloadQueued"] ? new Date(_data["downloadQueued"].toString()) : <any>undefined;
            this.downloadStarted = _data["downloadStarted"] ? new Date(_data["downloadStarted"].toString()) : <any>undefined;
            this.downloadFinished = _data["downloadFinished"] ? new Date(_data["downloadFinished"].toString()) : <any>undefined;
            this.unpackingQueued = _data["unpackingQueued"] ? new Date(_data["unpackingQueued"].toString()) : <any>undefined;
            this.unpackingStarted = _data["unpackingStarted"] ? new Date(_data["unpackingStarted"].toString()) : <any>undefined;
            this.unpackingFinished = _data["unpackingFinished"] ? new Date(_data["unpackingFinished"].toString()) : <any>undefined;
            this.completed = _data["completed"] ? new Date(_data["completed"].toString()) : <any>undefined;
            this.retryCount = _data["retryCount"];
            this.error = _data["error"];
            this.remoteId = _data["remoteId"];
            this.fileName = _data["fileName"];
            this.bytesTotal = _data["bytesTotal"];
            this.bytesDone = _data["bytesDone"];
            this.speed = _data["speed"];
        }
    }

    static fromJS(data: any): Download {
        data = typeof data === 'object' ? data : {};
        let result = new Download();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadId"] = this.downloadId;
        data["torrentId"] = this.torrentId;
        data["torrent"] = this.torrent ? this.torrent.toJSON() : <any>undefined;
        data["path"] = this.path;
        data["link"] = this.link;
        data["added"] = this.added ? this.added.toISOString() : <any>undefined;
        data["downloadQueued"] = this.downloadQueued ? this.downloadQueued.toISOString() : <any>undefined;
        data["downloadStarted"] = this.downloadStarted ? this.downloadStarted.toISOString() : <any>undefined;
        data["downloadFinished"] = this.downloadFinished ? this.downloadFinished.toISOString() : <any>undefined;
        data["unpackingQueued"] = this.unpackingQueued ? this.unpackingQueued.toISOString() : <any>undefined;
        data["unpackingStarted"] = this.unpackingStarted ? this.unpackingStarted.toISOString() : <any>undefined;
        data["unpackingFinished"] = this.unpackingFinished ? this.unpackingFinished.toISOString() : <any>undefined;
        data["completed"] = this.completed ? this.completed.toISOString() : <any>undefined;
        data["retryCount"] = this.retryCount;
        data["error"] = this.error;
        data["remoteId"] = this.remoteId;
        data["fileName"] = this.fileName;
        data["bytesTotal"] = this.bytesTotal;
        data["bytesDone"] = this.bytesDone;
        data["speed"] = this.speed;
        return data;
    }
}

export interface IDownload {
    downloadId?: string;
    torrentId?: string;
    torrent?: Torrent | undefined;
    path?: string;
    link?: string | undefined;
    added?: Date;
    downloadQueued?: Date | undefined;
    downloadStarted?: Date | undefined;
    downloadFinished?: Date | undefined;
    unpackingQueued?: Date | undefined;
    unpackingStarted?: Date | undefined;
    unpackingFinished?: Date | undefined;
    completed?: Date | undefined;
    retryCount?: number;
    error?: string | undefined;
    remoteId?: string | undefined;
    fileName?: string | undefined;
    bytesTotal?: number;
    bytesDone?: number;
    speed?: number;
}

export enum Provider {
    RealDebrid = 0,
    AllDebrid = 1,
    Premiumize = 2,
    TorBox = 3,
    DebridLink = 4,
}

export enum TorrentStatus {
    Processing = 0,
    WaitingForFileSelection = 1,
    Downloading = 2,
    Finished = 3,
    Uploading = 4,
    Error = 99,
}

export class TorrentClientFile implements ITorrentClientFile {
    id?: number;
    path?: string;
    bytes?: number;
    selected?: boolean;
    downloadLink?: string | undefined;

    constructor(data?: ITorrentClientFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.path = _data["path"];
            this.bytes = _data["bytes"];
            this.selected = _data["selected"];
            this.downloadLink = _data["downloadLink"];
        }
    }

    static fromJS(data: any): TorrentClientFile {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentClientFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["path"] = this.path;
        data["bytes"] = this.bytes;
        data["selected"] = this.selected;
        data["downloadLink"] = this.downloadLink;
        return data;
    }
}

export interface ITorrentClientFile {
    id?: number;
    path?: string;
    bytes?: number;
    selected?: boolean;
    downloadLink?: string | undefined;
}

/** Request model for uploading a torrent file */
export class TorrentControllerUploadFileRequest implements ITorrentControllerUploadFileRequest {
    /** Configuration for the torrent download */
    torrent!: Torrent;

    constructor(data?: ITorrentControllerUploadFileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.torrent = new Torrent();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.torrent = _data["torrent"] ? Torrent.fromJS(_data["torrent"]) : new Torrent();
        }
    }

    static fromJS(data: any): TorrentControllerUploadFileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentControllerUploadFileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["torrent"] = this.torrent ? this.torrent.toJSON() : <any>undefined;
        return data;
    }
}

/** Request model for uploading a torrent file */
export interface ITorrentControllerUploadFileRequest {
    /** Configuration for the torrent download */
    torrent: Torrent;
}

/** Request model for adding a magnet link */
export class TorrentControllerUploadMagnetRequest implements ITorrentControllerUploadMagnetRequest {
    /** The magnet URI to process */
    magnetLink!: string;
    /** Configuration for the torrent download */
    torrent!: Torrent;

    constructor(data?: ITorrentControllerUploadMagnetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.torrent = new Torrent();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.magnetLink = _data["magnetLink"];
            this.torrent = _data["torrent"] ? Torrent.fromJS(_data["torrent"]) : new Torrent();
        }
    }

    static fromJS(data: any): TorrentControllerUploadMagnetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentControllerUploadMagnetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["magnetLink"] = this.magnetLink;
        data["torrent"] = this.torrent ? this.torrent.toJSON() : <any>undefined;
        return data;
    }
}

/** Request model for adding a magnet link */
export interface ITorrentControllerUploadMagnetRequest {
    /** The magnet URI to process */
    magnetLink: string;
    /** Configuration for the torrent download */
    torrent: Torrent;
}

export class TorrentClientAvailableFile implements ITorrentClientAvailableFile {
    filename?: string;
    filesize?: number;

    constructor(data?: ITorrentClientAvailableFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filename = _data["filename"];
            this.filesize = _data["filesize"];
        }
    }

    static fromJS(data: any): TorrentClientAvailableFile {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentClientAvailableFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["filesize"] = this.filesize;
        return data;
    }
}

export interface ITorrentClientAvailableFile {
    filename?: string;
    filesize?: number;
}

/** Request model for checking files in a magnet link */
export class TorrentControllerCheckFilesRequest implements ITorrentControllerCheckFilesRequest {
    /** The magnet URI to analyze */
    magnetLink!: string;

    constructor(data?: ITorrentControllerCheckFilesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.magnetLink = _data["magnetLink"];
        }
    }

    static fromJS(data: any): TorrentControllerCheckFilesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentControllerCheckFilesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["magnetLink"] = this.magnetLink;
        return data;
    }
}

/** Request model for checking files in a magnet link */
export interface ITorrentControllerCheckFilesRequest {
    /** The magnet URI to analyze */
    magnetLink: string;
}

/** Request model for deleting a torrent */
export class TorrentControllerDeleteRequest implements ITorrentControllerDeleteRequest {
    /** Whether to delete the downloaded data */
    deleteData?: boolean;
    /** Whether to remove the torrent from the Debrid service */
    deleteRdTorrent?: boolean;
    /** Whether to delete local torrent files */
    deleteLocalFiles?: boolean;

    constructor(data?: ITorrentControllerDeleteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deleteData = _data["deleteData"];
            this.deleteRdTorrent = _data["deleteRdTorrent"];
            this.deleteLocalFiles = _data["deleteLocalFiles"];
        }
    }

    static fromJS(data: any): TorrentControllerDeleteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentControllerDeleteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deleteData"] = this.deleteData;
        data["deleteRdTorrent"] = this.deleteRdTorrent;
        data["deleteLocalFiles"] = this.deleteLocalFiles;
        return data;
    }
}

/** Request model for deleting a torrent */
export interface ITorrentControllerDeleteRequest {
    /** Whether to delete the downloaded data */
    deleteData?: boolean;
    /** Whether to remove the torrent from the Debrid service */
    deleteRdTorrent?: boolean;
    /** Whether to delete local torrent files */
    deleteLocalFiles?: boolean;
}

/** Response model for regex verification results */
export class RegexVerificationResult implements IRegexVerificationResult {
    /** Error message for the include regex pattern, if any */
    includeError?: string;
    /** Error message for the exclude regex pattern, if any */
    excludeError?: string;
    /** Files that match the specified patterns */
    selectedFiles?: TorrentClientAvailableFile[];

    constructor(data?: IRegexVerificationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeError = _data["includeError"];
            this.excludeError = _data["excludeError"];
            if (Array.isArray(_data["selectedFiles"])) {
                this.selectedFiles = [] as any;
                for (let item of _data["selectedFiles"])
                    this.selectedFiles!.push(TorrentClientAvailableFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegexVerificationResult {
        data = typeof data === 'object' ? data : {};
        let result = new RegexVerificationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeError"] = this.includeError;
        data["excludeError"] = this.excludeError;
        if (Array.isArray(this.selectedFiles)) {
            data["selectedFiles"] = [];
            for (let item of this.selectedFiles)
                data["selectedFiles"].push(item.toJSON());
        }
        return data;
    }
}

/** Response model for regex verification results */
export interface IRegexVerificationResult {
    /** Error message for the include regex pattern, if any */
    includeError?: string;
    /** Error message for the exclude regex pattern, if any */
    excludeError?: string;
    /** Files that match the specified patterns */
    selectedFiles?: TorrentClientAvailableFile[];
}

/** Request model for verifying regex patterns */
export class TorrentControllerVerifyRegexRequest implements ITorrentControllerVerifyRegexRequest {
    /** Pattern for including files */
    includeRegex?: string | undefined;
    /** Pattern for excluding files */
    excludeRegex?: string | undefined;
    /** Magnet link to test patterns against */
    magnetLink?: string | undefined;

    constructor(data?: ITorrentControllerVerifyRegexRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeRegex = _data["includeRegex"];
            this.excludeRegex = _data["excludeRegex"];
            this.magnetLink = _data["magnetLink"];
        }
    }

    static fromJS(data: any): TorrentControllerVerifyRegexRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TorrentControllerVerifyRegexRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeRegex"] = this.includeRegex;
        data["excludeRegex"] = this.excludeRegex;
        data["magnetLink"] = this.magnetLink;
        return data;
    }
}

/** Request model for verifying regex patterns */
export interface ITorrentControllerVerifyRegexRequest {
    /** Pattern for including files */
    includeRegex?: string | undefined;
    /** Pattern for excluding files */
    excludeRegex?: string | undefined;
    /** Magnet link to test patterns against */
    magnetLink?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}